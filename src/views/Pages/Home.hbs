
{{#> layout name="main" }}
<!-- Bootstrap CSS -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
<div class="container pt-3">
    <div class="row justify-content-center">
        <div class="col-md-8 col-lg-6">
            {{#if error}}
            <div class="alert alert-danger">{{error}}</div>
            {{/if}}

            <div class="card shadow-lg position-relative">
                <!-- grey overlay -->
                <div id="contentOverlay"
                    class="position-absolute top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center"
                    style="background-color: rgba(0,0,0,0.7); z-index: 10; border-radius: inherit;">
                    <div class="text-center p-4 rounded bg-dark bg-opacity-75">
                        <h2 class="text-white mb-4">Ready to find your next meal?</h2>
                        <button class="btn btn-lg btn-primary px-4 py-2" data-bs-toggle="modal"
                            data-bs-target="#startSessionModal">
                            <i class="bi bi-people-fill me-2"></i>Start!
                        </button>
                    </div>
                </div>

                <div class="card-body p-0">
                    <!-- main card -->
                    <div id="restaurant-card" class="position-relative">
                        <div class="position-relative">
                            <img id="restaurant-image" src="" class="card-img-top" alt="Restaurant Image"
                                style="height: 250px; object-fit: cover;">
                            <button id="info-btn"
                                class="btn btn-light btn-sm rounded-3 position-absolute bottom-0 end-0 m-3 shadow">
                                <i class="bi bi-info-lg"></i> Details
                            </button>
                        </div>
                        <div class="p-3">
                            <h4 id="restaurant-name"></h4>
                            <div id="restaurant-badges" class="mb-2">
                            </div>
                            <p id="restaurant-description" class="mb-2"></p>
                            <p id="restaurant-distance" class="text-muted small mb-0"></p>
                        </div>
                    </div>

                    <div class="swipe-controls d-flex justify-content-around py-3 bg-light">
                        <button id="dislike-btn" class="btn btn-lg btn-outline-danger rounded-3 px-4" disabled>
                            <i class="bi bi-x-lg"></i> Nope
                        </button>
                        <button id="like-btn" class="btn btn-lg btn-outline-success rounded-3 px-4" disabled>
                            <i class="bi bi-heart-fill"></i> Like
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Start Session Modal -->
<div class="modal fade" id="startSessionModal" tabindex="-1" aria-labelledby="startSessionModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="startSessionModalLabel">Start Finding Restaurants</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="groupForm">
                    <div class="mb-3">
                        <label for="groupName" class="form-label">Group Name (optional)</label>
                        <input type="text" class="form-control" id="groupName" placeholder="Enter a name for your group">
                    </div>
                    
                    <div class="mb-3">
                        <label for="location" class="form-label">Location</label>
                        <input type="text" class="form-control" id="location" placeholder="Enter city or ZIP code" required>
                        <div id="locationAutocomplete" class="list-group mt-2 d-none"></div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Friends (optional)</label>
                        <div id="friendSelection">
                            {{#if friends}}
          <div class="mb-3">
            <label for="friendUsername" class="form-label">Invite a Friend</label>
            <select id="friendUsername" class="form-select">
              <option value="">Select a friend</option>
              {{#each friends}}
                <option value="{{this.username}}">{{this.username}}</option>
              {{/each}}
            </select>
          </div>

                            <div id="selectedFriends" class="d-flex flex-wrap gap-2 my-2"></div>
                            {{else}}
                            <p class="text-muted fst-italic">No friends available. <a href="/friends">Add friends</a> to invite them.</p>
                            {{/if}}
                        </div>
                    </div>

                    <div class="mb-3">
                        <label class="form-label">Restaurant Type (optional)</label>
                        <div class="d-flex flex-wrap gap-2">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" value="cafe" id="cafe" checked>
                                <label class="form-check-label" for="cafe">Cafe</label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" value="bar" id="bar" checked>
                                <label class="form-check-label" for="bar">Bar</label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" value="restaurant" id="restaurant" checked>
                                <label class="form-check-label" for="restaurant">Restaurant</label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" value="fine_dining" id="fine_dining" checked>
                                <label class="form-check-label" for="fine_dining">Fine Dining</label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" value="bakery" id="bakery" checked>
                                <label class="form-check-label" for="bakery">Bakery</label>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="startSessionBtn">Start Swiping</button>
            </div>
        </div>
    </div>
</div>

<!-- Match Modal -->
<div class="modal fade" id="matchModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-body text-center py-4">
                <h3 class="display-6 mb-4">It's a Match! üéâ</h3>
                <div class="match-restaurant mb-3">
                    <img id="match-restaurant-image" class="rounded mb-2 img-fluid" alt="Restaurant"
                        style="max-width: 100%;">
                    <h4 id="match-restaurant-name"></h4>
                    <p class="text-muted">Everyone likes this place!</p>
                </div>
                <div class="d-grid gap-2">
                    <a id="match-restaurant-link" class="btn btn-primary" target="_blank">View on Google Maps</a>
                    <button class="btn btn-primary">Play a minigame to decide who pays</button>
                    <button class="btn btn-outline-secondary" data-bs-dismiss="modal">Continue Swiping</button>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- Waiting Overlay -->
<div id="waitingOverlay" class="position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center bg-dark bg-opacity-75 text-white fw-bold fs-4 d-none" style="z-index: 1050;">
  Waiting on your friend to join the session...
</div>


<!-- Invitation Modal -->
<div class="modal fade" id="inviteModal" tabindex="-1" aria-labelledby="inviteModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="inviteModalLabel">Swipe Session Invite</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        A friend invited you to join a swiping session.
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" id="joinSwipeBtn">Join Swiping</button>
      </div>
    </div>
  </div>
</div>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const modalEl = document.getElementById('inviteModal');
    console.log('üîç Test: inviteModalEl is', modalEl);
  });
</script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
<style>
    #restaurant-card {
        transition: transform 0.3s ease;
    }

    .swipe-left {
        transform: translateX(-150%) rotate(-15deg);
        transition: all 0.5s ease;
    }

    .swipe-right {
        transform: translateX(150%) rotate(15deg);
        transition: all 0.5s ease;
    }

    #info-btn {
        opacity: 0.9;
    }

    #info-btn:hover {
        opacity: 1;
    }

    #contentOverlay {
        transition: opacity 0.5s ease;
        pointer-events: auto;
    }

    #contentOverlay>* {
        pointer-events: auto;
    }

    #contentOverlay[style*="display: none"] {
        pointer-events: none;
    }

    .btn:disabled {
        opacity: 0.65;
        cursor: not-allowed;
    }

    #locationAutocomplete {
        position: absolute;
        z-index: 1000;
        width: 100%;
        max-height: 200px;
        overflow-y: auto;
    }

    #locationAutocomplete .list-group-item {
        cursor: pointer;
    }

    #locationAutocomplete .list-group-item:hover {
        background-color: #f8f9fa;
    }

    /* Update cursor for buttons */
    #like-btn, #dislike-btn {
        cursor: pointer;
    }
</style>

<!-- Socket.IO Client Script -->

<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCxYA0OMGoBZ093MoeamguWrt7jfxl44EU&libraries=places&loading=async&callback=initMap"></script>
<script src="/socket.io/socket.io.js"></script>
<script>
   
     const socket = io();

  document.addEventListener('DOMContentLoaded', () => {
console.log('üöÄ DOM loaded and JS running');

     console.log('‚úÖ Socket initialized:', socket);

    const userId = {{user.user_id}};
    console.log('Loaded userId from template:', userId);

    let groupId = null;



socket.on('connect', () => {
  console.log('‚úÖ Connected, socket id:', socket.id);
  socket.emit('register-user', { userId });
});

    console.log('‚úÖ Registered user', userId);

console.log('üì° Setting up invite listener'); // A ‚Äî you‚Äôre attaching the listener

let sessionLat = null;
let sessionLng = null;
let sessionTypes = [];

socket.on('invite-user-to-session', ({ groupId, lat, lng, types }) => {
  console.log('üî• invite-user-to-session event received');
  console.log('üîî About to show the invite modal for group:', groupId);
  sessionLat = lat;
  sessionLng = lng;
  sessionTypes = types || [];
  const inviteModalEl = document.getElementById('inviteModal');
  const joinBtn = document.getElementById('joinSwipeBtn');

  if (!inviteModalEl || !joinBtn) {
    console.error('‚ùå Modal or button missing');
    return;
  }

  const modal = bootstrap.Modal.getOrCreateInstance(inviteModalEl);
  modal.show();
  console.log('‚úÖ Modal.show() called');

  joinBtn.onclick = () => {
    console.log('üì¨ Accepting invite for group', groupId);
    socket.emit('join-session', { groupId, userId });
    socket.emit('accept-session-invite', { groupId, userId });
    socket.emit('ready-to-swipe', { groupId, userId, lat: sessionLat, lng: sessionLng, types: sessionTypes });
    modal.hide();
    document.body.classList.remove('modal-open');
    document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
  };
});

    // START SESSION
    document.getElementById('startSessionBtn')?.addEventListener('click', async () => {
      const groupName = document.getElementById('groupName')?.value || 'Session';
      const location = document.getElementById('location')?.value;
      const friendUsername = document.getElementById('friendUsername')?.value;

      if (!location) {
        alert('Please enter a location');
        return;
      }

      try {
        // Geocode the location first
        const geoResults = await new Promise((resolve, reject) => {
          geocoder.geocode({ address: location }, (results, status) => {
            if (status === 'OK') resolve(results);
            else reject(status);
          });
        });

        const geocodedLat = geoResults[0].geometry.location.lat();
        const geocodedLng = geoResults[0].geometry.location.lng();
        console.log('Geocoded coordinates:', geocodedLat, geocodedLng);

        const res = await fetch('/groups', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: groupName,
            location: location,
            lat: geocodedLat,
            lng: geocodedLng
          })
        });

        if (!res.ok) {
          const text = await res.text();
          console.error('‚ùå Server returned error:', res.status, text);
          alert('Failed to start session');
          return;
        }

        const data = await res.json();
        if (!data.success) {
          alert('Failed to start session');
          return;
        }

        groupId = data.group_id;
        console.log('‚úÖ Group created with ID:', groupId);

        // Join own group room
        socket.emit('join-session', { groupId, userId });

        socket.on('friend-accepted-invite', () => {
          socket.emit('ready-to-swipe', { groupId, userId, lat: geocodedLat, lng: geocodedLng });
        });

        // Send invite to friend
        if (friendUsername) {
          setTimeout(() => {
            console.log('üì® Emitting invite-user-by-username', friendUsername, groupId);
            const selectedTypes = Array.from(document.querySelectorAll('.form-check-input:checked'))
              .map(cb => cb.value)
              .filter(v => v !== 'on');
            console.log(`üì§ Sending invite with types:`, selectedTypes);

            socket.emit('invite-user-by-username', {
              username: friendUsername,
              groupId,
              lat: geocodedLat,
              lng: geocodedLng,
              types: selectedTypes
            });
          }, 1000);
        }

        // Show waiting UI
        document.getElementById('waitingOverlay')?.classList.remove('d-none');

      } catch (err) {
        console.error('‚ùå Geocoding or session start error:', err);
        alert('Failed to start session');
      }
    });

    // RECEIVE INVITE


    // START SWIPING

socket.emit('register-user', { userId }, () => {
  console.log('üß† Confirmed user registered on server');
  socket.emit('ready-for-invites', { userId });  // <- this is key
});


  });








    let currentRestaurants = [];
    let currentIndex = 0;
    let currentGroupId = null;
    let selectedFriends = [];
    let service;
    let geocoder;
    let autocompleteService;
    let mapDiv;

    function initMap() {
        console.log("Google Maps API loaded successfully");
        
        // Initialize Google Maps services
        geocoder = new google.maps.Geocoder();
        
        // Create a map div for Places service (required)
        mapDiv = document.createElement('div');
        mapDiv.style.display = 'none';
        document.body.appendChild(mapDiv);
        
        // Create a hidden map instance
        const map = new google.maps.Map(mapDiv, {
            center: { lat: 0, lng: 0 },
            zoom: 2
        });
        
        // Initialize services with the map
        service = new google.maps.places.PlacesService(map);
        autocompleteService = new google.maps.places.AutocompleteService();
    
        // Initialize UI elements
        const likeBtn = document.getElementById('like-btn');
        const dislikeBtn = document.getElementById('dislike-btn');
        const infoBtn = document.getElementById('info-btn');
        const restaurantCard = document.getElementById('restaurant-card');
        const contentOverlay = document.getElementById('contentOverlay');
        const startSessionBtn = document.getElementById('startSessionBtn');
        const startSessionModal = document.getElementById('startSessionModal');
        const matchModal = new bootstrap.Modal(document.getElementById('matchModal'));
        const locationInput = document.getElementById('location');
        const locationAutocomplete = document.getElementById('locationAutocomplete');
        const addFriendBtn = document.getElementById('addFriendBtn');
        const friendSelect = document.getElementById('friendSelect');
        const selectedFriendsDiv = document.getElementById('selectedFriends');
        const friendUsername = document.getElementById('friendUsername').value || null;


        const modal = new bootstrap.Modal(startSessionModal);

        // Setup location autocomplete
        locationInput.addEventListener('input', function() {
            if (this.value.length > 2) {
                autocompleteService.getPlacePredictions({
                    input: this.value,
                    types: ['(cities)']
                }, (predictions, status) => {
                    if (status === google.maps.places.PlacesServiceStatus.OK) {
                        locationAutocomplete.innerHTML = '';
                        predictions.forEach(prediction => {
                            const item = document.createElement('a');
                            item.className = 'list-group-item list-group-item-action';
                            item.textContent = prediction.description;
                            item.addEventListener('click', () => {
                                locationInput.value = prediction.description;
                                locationAutocomplete.classList.add('d-none');
                                geocoder.geocode({ placeId: prediction.place_id }, (results, status) => {
                                    if (status === 'OK') {
                                        const latlng = {
                                            lat: results[0].geometry.location.lat(),
                                            lng: results[0].geometry.location.lng()
                                        };
                                        console.log('Location found:', latlng);
                                    }
                                });
                            });
                            locationAutocomplete.appendChild(item);
                        });
                        locationAutocomplete.classList.remove('d-none');
                    }
                });
            } else {
                locationAutocomplete.classList.add('d-none');
            }
        });

        // Setup friend selection
        if (addFriendBtn && friendSelect) {
            addFriendBtn.addEventListener('click', function() {
                const friendId = friendSelect.value;
                const friendName = friendSelect.options[friendSelect.selectedIndex].text;
                
                if (friendId && !selectedFriends.some(f => f.id === friendId)) {
                    selectedFriends.push({
                        id: friendId,
                        name: friendName
                    });
                    
                    updateSelectedFriendsList();
                }
            });
        }

        function updateSelectedFriendsList() {
            if (selectedFriendsDiv) {
                selectedFriendsDiv.innerHTML = '';
                
                selectedFriends.forEach(friend => {
                    const badge = document.createElement('span');
                    badge.className = 'badge bg-primary d-flex align-items-center';
                    badge.innerHTML = `
                        ${friend.name}
                        <button type="button" class="btn-close btn-close-white ms-2" aria-label="Remove friend"></button>
                    `;
                    
                    const closeBtn = badge.querySelector('.btn-close');
                    closeBtn.addEventListener('click', () => {
                        selectedFriends = selectedFriends.filter(f => f.id !== friend.id);
                        updateSelectedFriendsList();
                    });
                    
                    selectedFriendsDiv.appendChild(badge);
                });
            }
        }


startSessionBtn.addEventListener('click', async function () {
  const location = locationInput.value;
  const groupName = document.getElementById('groupName')?.value || 'Solo Session';

  if (!location) {
    alert('Please enter a location');
    return;
  }

  // Get friend IDs
  const friendIds = selectedFriends.map(f => f.id);

  // Geocode the location to get lat/lng
  try {
    const geoResults = await new Promise((resolve, reject) => {
      geocoder.geocode({ address: location }, (results, status) => {
        if (status === 'OK') resolve(results);
        else reject(status);
      });
    });

    const geocodedLat = geoResults[0].geometry.location.lat();
    const geocodedLng = geoResults[0].geometry.location.lng();
    console.log('Geocoded:', geocodedLat, geocodedLng);

    // Send group creation request to backend
    const response = await fetch('/groups', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        name: groupName,
        location: location,
        friends: friendIds,
        lat: geocodedLat,
        lng: geocodedLng
      })
    });

    const data = await response.json();

    if (data.success) {
      currentGroupId = data.group_id;
      console.log('Group created with ID:', currentGroupId);
      searchNearbyRestaurants({ lat: geocodedLat, lng: geocodedLng });

      contentOverlay.style.opacity = '0';
      setTimeout(() => {
        contentOverlay.style.display = 'none';
        likeBtn.removeAttribute('disabled');
        dislikeBtn.removeAttribute('disabled');
      }, 500);

      modal.hide();
      document.body.classList.remove('modal-open');
document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());

    } else {
      console.error('Group creation failed:', data.error);
      alert('Failed to start session');
    }
  } catch (err) {
    console.error('Geocoding or session start error:', err);
    alert('Failed to start session');
  }
});

       

        function searchNearbyRestaurants(location, radius) {
            console.log('Starting restaurant search at location:', location);
            
            const request = {
                location : location,
                radius   : radius || 5000,
                type     : 'restaurant'
            };
            
            // Define valid restaurant types
            const validTypes = [
                'restaurant',
                'cafe',
                'bar',
                'bakery',
                'meal_delivery',
                'meal_takeaway',
                'food'
            ];
            
            // Get selected types from checkboxes
            const selectedTypes = Array.from(document.querySelectorAll('.form-check-input:checked'))
                .map(cb => cb.value)
                .filter(v => v !== 'on');
            
            console.log('Selected types:', selectedTypes);
            
            // Only add keyword filter if specific types are selected
            if (selectedTypes.length > 0) {
                request.keyword = selectedTypes.join(' ');
            }
            
            service.nearbySearch(request, (results, status) => {
                if (status === google.maps.places.PlacesServiceStatus.OK) {
                    console.log('Found restaurants:', results.length);
                    
                    // Define the valid restaurant types we want to show
                    const validTypes = ['restaurant', 'cafe', 'bar', 'bakery', 'meal_takeaway', 'food'];
                    
                    // Filter to only include places matching our desired types
                    currentRestaurants = results.filter(place => {
                        // First check if the place is operational
                        if (place.business_status !== 'OPERATIONAL') {
                            return false;
                        }
                        
                        // If no types are selected, only show actual restaurants
                        if (selectedTypes.length === 0) {
                            return place.types && 
                                   place.types.some(type => validTypes.includes(type));
                        }
                        
                        // If types are selected, ensure the place matches at least one selected type
                        return place.types && 
                               place.types.some(type => selectedTypes.includes(type));
                    });
                    
                    console.log('Filtered restaurants:', currentRestaurants.length);
                    
                    if (currentRestaurants.length > 0) {
                        currentIndex = 0;
                        showNextRestaurant();
                    } else {
                        alert('No restaurants found matching your criteria. Try adjusting your filters or location.');
                    }
                } else {
                    console.error('Places API error:', status);
                    alert('Error searching for restaurants. Please try again.');
                }
            });
        }

        function showNextRestaurant() {
            console.log('Showing restaurant at index:', currentIndex);
            if (currentIndex >= currentRestaurants.length) {
                console.log('No more restaurants to show');
                alert('No more restaurants to show!');
                return;
            }

            const restaurant = currentRestaurants[currentIndex];
            console.log('Current restaurant:', restaurant);
            
            try {
                // Get detailed place information
                const request = {
                    placeId: restaurant.place_id,
                    fields: [
                        'name',
                        'rating',
                        'formatted_address',
                        'photos',
                        'price_level',
                        'website',
                        'url',
                        'opening_hours',
                        'reviews'
                    ]
                };

                service.getDetails(request, (place, status) => {
                    console.log('Place details status:', status);
                    if (status === google.maps.places.PlacesServiceStatus.OK) {
                        console.log('Place details:', place);
                        
                        // Update restaurant name
                        document.getElementById('restaurant-name').textContent = place.name;
                        
                        // Update badges (price and rating)
                        const badges = [];
                        if (place.price_level) {
                            badges.push(`<span class="badge bg-success me-1">${'$'.repeat(place.price_level)}</span>`);
                        }
                        if (place.rating) {
                            badges.push(`<span class="badge bg-secondary me-1">${place.rating} ‚òÖ</span>`);
                        }
                        if (place.opening_hours && place.opening_hours.isOpen) {
                            badges.push(`<span class="badge bg-success me-1">Open Now</span>`);
                        }
                        document.getElementById('restaurant-badges').innerHTML = badges.join('');
                        
                        // Update description
                        document.getElementById('restaurant-description').textContent = place.formatted_address || restaurant.vicinity || 'No address available';
                        
                        // Update image
                        const restaurantImage = document.getElementById('restaurant-image');
                        if (place.photos && place.photos[0]) {
                            try {
                                restaurantImage.src = place.photos[0].getUrl({
                                    maxWidth: 800,
                                    maxHeight: 600
                                });
                            } catch (error) {
                                console.error('Error getting photo URL:', error);
                                restaurantImage.src = 'https://via.placeholder.com/800x600?text=Restaurant+Image';
                            }
                        } else {
                            // Set a default image if no photos are available
                            restaurantImage.src = 'https://via.placeholder.com/800x600?text=No+Image+Available';
                        }

                        // Update info button to link to Google Maps
                        infoBtn.onclick = () => {
                            if (place.url) {
                                window.open(place.url, '_blank');
                            } else {
                                window.open(`https://www.google.com/maps/place/?q=place_id:${restaurant.place_id}`, '_blank');
                            }
                        };
                    } else {
                        console.error('Failed to get place details:', status);
                        
                        // Use basic restaurant info from search results
                        document.getElementById('restaurant-name').textContent = restaurant.name;
                        
                        const badges = [];
                        if (restaurant.price_level) {
                            badges.push(`<span class="badge bg-success me-1">${'$'.repeat(restaurant.price_level)}</span>`);
                        }
                        if (restaurant.rating) {
                            badges.push(`<span class="badge bg-secondary me-1">${restaurant.rating} ‚òÖ</span>`);
                        }
                        document.getElementById('restaurant-badges').innerHTML = badges.join('');
                        
                        document.getElementById('restaurant-description').textContent = restaurant.vicinity || 'No address available';
                        
                        const restaurantImage = document.getElementById('restaurant-image');
                        if (restaurant.photos && restaurant.photos[0]) {
                            try {
                                restaurantImage.src = restaurant.photos[0].getUrl({
                                    maxWidth: 800,
                                    maxHeight: 600
                                });
                            } catch (error) {
                                restaurantImage.src = 'https://via.placeholder.com/800x600?text=Restaurant+Image';
                            }
                        } else {
                            restaurantImage.src = 'https://via.placeholder.com/800x600?text=No+Image+Available';
                        }
                        
                        infoBtn.onclick = () => window.open(`https://www.google.com/maps/place/?q=place_id:${restaurant.place_id}`, '_blank');
                    }
                });
            } catch (error) {
                console.error('Error in showNextRestaurant:', error);
                if (currentIndex < currentRestaurants.length) {
                    showNextRestaurant();
                } else {
                    alert('No more restaurants to show!');
                }
            }
        }

          likeBtn.addEventListener('click', function () {
            restaurantCard.classList.add('swipe-right');
            setTimeout(() => {
              restaurantCard.classList.remove('swipe-right');
              handleVote(true);
            }, 500);
          });

          dislikeBtn.addEventListener('click', function () {
            restaurantCard.classList.add('swipe-left');
            setTimeout(() => {
              restaurantCard.classList.remove('swipe-left');
              handleVote(false);
            }, 500);
          });

        // Add keyboard controls
        document.addEventListener('keydown', function(e) {
            if (!likeBtn.disabled) {
                if (e.key === 'ArrowRight') {
                    likeBtn.click();
                } else if (e.key === 'ArrowLeft') {
                    dislikeBtn.click();
                }
            }
        });
    
socket.on('start-swiping', ({ groupId, lat, lng, types }) => {
  currentGroupId = groupId;

  console.log('üöÄ All users ready ‚Äî swiping begins!');
  console.log('üéØ Received filter types on receiver:', types);
  document.getElementById('waitingOverlay')?.classList.add('d-none');
  
  // üí° Only now remove the gray overlay
  contentOverlay.style.opacity = '0';
  setTimeout(() => {
    contentOverlay.style.display = 'none';
    likeBtn.removeAttribute('disabled');
    dislikeBtn.removeAttribute('disabled');
  }, 500);

  if (lat && lng) {
    console.log('üìç Fetching restaurants as receiver...');
    searchNearbyRestaurants({ lat: parseFloat(lat), lng: parseFloat(lng) }, 5000);
  }

  likeBtn.removeAttribute('disabled');
  dislikeBtn.removeAttribute('disabled');

  sessionStorage.setItem('lat', lat);
  sessionStorage.setItem('lng', lng);
  sessionStorage.setItem('radius', 5000);
});

socket.on('peer-swipe', ({ userId, restaurantId, direction }) => {
  console.log({ userId, restaurantId, direction });
});

socket.on('group-match', ({ restaurant }) => {
  console.log(restaurant);

  // Show match modal
  document.getElementById('match-restaurant-name').textContent = restaurant.name;
  const matchImage = document.getElementById('match-restaurant-image');

  // Try to get the restaurant photo
  if (restaurant.photos && restaurant.photos[0]) {
    try {
      matchImage.src = restaurant.photos[0].getUrl({
        maxWidth: 800,
        maxHeight: 600
      });
    } catch (_) {
      matchImage.src = 'https://via.placeholder.com/800x600?text=Restaurant+Image';
    }
  } else {
    matchImage.src = 'https://via.placeholder.com/800x600?text=Restaurant+Image';
  }

  document.getElementById('match-restaurant-link').href = 
    `https://www.google.com/maps/place/?q=place_id:${restaurant.place_id}`;
  matchModal.show();
});

function handleVote(liked) {
  if (!currentRestaurants || !currentRestaurants[currentIndex]) {
    console.error('No current restaurant to vote on');
    alert('Error: No restaurant to vote on');
    return;
  }

  const restaurant = currentRestaurants[currentIndex];

  restaurant.swipeDirection = liked ? 'right' : 'left';
  restaurant.lat = restaurant.geometry?.location?.lat() || 0;
  restaurant.lng = restaurant.geometry?.location?.lng() || 0;

  socket.emit('user-swipe', {
    groupId    : currentGroupId,
    userId     : {{user.user_id}},
    restaurant : restaurant
  });

  // Show next restaurant
  currentIndex++;
  if (currentIndex < currentRestaurants.length) {
    showNextRestaurant();
  } else {
    // Search for more restaurants with a wider radius
    let radius = parseInt(sessionStorage.getItem('radius'));
    radius += (radius / 2);
    sessionStorage.setItem('radius', radius);

    searchNearbyRestaurants({
      lat : parseFloat(sessionStorage.getItem('lat')),
      lng : parseFloat(sessionStorage.getItem('lng'))
    }, radius);
  }
}

}

    // If the API has already loaded, initialize the map
    if (window.google && window.google.maps) {
        console.log("Google Maps already loaded, initializing map");
        initMap();
    }
window.initMap = initMap;

</script>
{{/layout}}
